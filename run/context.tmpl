{{ define "package" }}
{{- template "header" . }}
{{ template "definitions" . }}
{{ template "helpers" . }}
{{ template "func-page-files" . }}
{{ if .NoCache }}
	{{ template "func-page-template-nocache" . }}
{{ else }}
	{{ template "func-init" . }}
	{{ template "func-page-template" . }}
{{ end }}
{{ template "func-page-base" . }}
{{ template "func-page-execute" . }}
{{ template "func-main" . }}
{{ end }}



{{ define "header" }}
// Generated by {{ .ProgramName }}; *** DO NOT EDIT ***
// Created: {{ .Timestamp.Format "2006-01-02 15:04:05" }}
// Params: no_cache={{ .NoCache }}, no_go_format={{ .NoGoFormat }}, asset_manager="{{ .AssetManager }}", func_map="{{ .FuncMap }}"

package {{ .PackageName }}

import (
{{ if .TextTemplate -}}
	"text/template"
{{- else -}}
	"html/template"
{{- end }}
	"io"
	"path/filepath"
)
{{ end }}


{{ define "definitions" }}
	// type definitions
	type (
		{{ .TemplateEnumType }} {{ uint (len .Templates) }}
		{{ .PageEnumType }} {{ uint (len .Pages) }}
	)
	// {{ .PageEnumType }} constants
	const templatesLen = {{ len .Templates }}
	const (
		{{ range $idx, $elem := .Pages -}}
			{{ $.PageName $elem }}{{ if eq $idx 0 }} {{ $.PageEnumType }} = iota{{ end }}
		{{ end -}}
	)
	{{ if not .NoCache }}
	// module variables
	var mTemplates [templatesLen]*template.Template
	{{ end }}
{{ end }}



{{ define "helpers" }}
{{ if .AssetManager.IsNone -}}
func files2paths(files []string) []string {
	const templatesFolder = "{{ .TemplateBaseDir }}"
	var path string
	paths := make([]string, len(files))
	for i, file := range files {
		switch {
		case len(file) == 0, file[0] == '.', file[0] == filepath.Separator:
			path = file
		default:
			path = filepath.Join(templatesFolder, file)
		}
		paths[i] = path
	}
	return paths
}
{{- end }}

// Files returns the files used by the `t` template
func (t {{ .TemplateEnumType }}) Files() []string {
	var (
		// files paths
		files = [...]string{ {{ astr2str .Files }}  }
		// template-index to array of file-index
		ti2afi = [...][]{{ uint (len .Files) }}{
		{{ range $idx, $aint := .TI2AFI -}}
			{ {{aint2str $aint}} }, // {{ index $.Templates $idx }}
		{{ end -}}
		}
	)
	// get the template files indexes
	idxs := ti2afi[t]
	// build the array of files
	astr := make([]string, len(idxs))
	for j, idx := range idxs {
		astr[j] = files[idx]
	}
	return astr
}
{{ end }}




{{ define "func-page-files" }}
// Files returns the files used by the template of the page
func (page {{ .PageEnumType }}) Files() []string {
	// from page to template indexes
	var p2t = [...]{{ .TemplateEnumType }}{
	{{- aint2str .PI2TI -}}
	}
	// get the template of the page
	t := p2t[page]
	return t.Files()
}
{{ end }}


{{ define "func-page-template" }}
// Template returns the template.Template of the page
func (page {{ .PageEnumType }}) Template() *template.Template {
	var idx = [...]{{ .TemplateEnumType }}{
                    {{- aint2str .PI2TI -}}
	}
	return mTemplates[idx[page]]
}
{{ end }}


{{ define "func-page-template-nocache" }}
// Template returns the template.Template of the page
func (page {{ .PageEnumType }}) Template() *template.Template {
files := page.Files()
{{ if .AssetManager.IsGoBindata }}
{{/*
	asset_manager == go-bindata
*/}}
// use go-bindata MustAsset func to load templates
tmpl := template.New(filepath.Base(files[0])){{ if .FuncMap }}.Funcs({{ .FuncMap }}){{ end }}
for _, path := range files {
	tmpl.Parse(string(MustAsset(path)))
}
return tmpl
{{ else }}
{{/*
	asset_manager == none
*/}}
return template.Must(
		{{- if .FuncMap -}}
		template.New(filepath.Base(files[0])).Funcs({{ .FuncMap }}).ParseFiles(files2paths(files)...)
		{{- else -}}
		template.ParseFiles(files2paths(files)...)
		{{- end -}}
	)
{{ end }}
}
{{ end }}


{{ define "func-page-base" }}
// Base returns the template name of the page
func (page {{ .PageEnumType }}) Base() string {
	var bases = [...]string{ {{astr2str .Bases }} }
	{{ if eq (len .Bases) (len .PI2BI) }}
		{{/* each page has a different base */}}
	return bases[page]
	{{ else }}
		{{/* some pages have the same base -> remap neede */}}
	var pi2bi = [...]{{ .PageEnumType }}{ {{aint2str .PI2BI}} }
	return bases[pi2bi[page]]
	{{ end }}
}
{{ end }}


{{ define "func-page-execute" }}
// Execute applies a parsed page template to the specified data object,
// writing the output to wr.
// If an error occurs executing the template or writing its output, execution
// stops, but partial results may already have been written to the output writer.
// A template may be executed safely in parallel.
func (page {{ .PageEnumType }}) Execute(wr io.Writer, data interface{}) error {
	tmpl := page.Template()
	name := page.Base()
	if name != "" {
		return tmpl.ExecuteTemplate(wr, name, data)
	}
	return tmpl.Execute(wr, data)
}
{{ end }}

{{ define "func-main" }}
/*
func main(){
	var page {{.PageEnumType}} = {{ .PageName (index .Pages 0) }}
	wr := os.Stdout

	if err := page.Execute(wr, nil); err != nil {
		fmt.Print(err)
	}
}
*/
{{ end }}


{{ define "toml" }}# gentmpl configuration file (TOML)

# Package name to use in the generated code. (default "templates")
{{ if .PackageName -}}
package_name = "{{ .PackageName }}"
{{- else -}}
#package_name = ""
{{- end }}

# Do not cache the templates.
# A new template will be created on every page.Execute.
# Usefull for debug purposes.
{{ if .NoCache -}}
no_cache = true
{{- else -}}
#no_cache = false
{{- end }}

# Do not format the generated code with go/format.
# Usefull for debug purposes.
{{ if .NoGoFormat -}}
no_go_format = true
{{- else -}}
#no_go_format = false
{{- end }}

# Asset manager to use. Possible values:
# - none (default)
# - go-bindata
{{ if not .AssetManager.IsNone -}}
asset_manager = "{{ .AssetManager }}"
{{- else -}}
#asset_manager = ""
{{- end }}

# Use text/template instead of html/template.
{{ if .TextTemplate -}}
text_template = true
{{- else -}}
#text_template = false
{{- end }}

# PageEnumType type name used in the generated package. (default "PageEnum")
{{ if .PageEnumType -}}
page_enum_type = "{{ .PageEnumType }}"
{{- else -}}
#page_enum_type = ""
{{- end }}

# Strings used as prefix and suffix in the PageEnum constants.
#   Defaults:
#     page_enum_prefix = "Page"
#     page_enum_suffix = ""
#   Example:
#     page "CreateUser", prefix="Page", suffix="" -> PageCreateUser
{{ if .PageEnumPrefix -}}
page_enum_prefix = "{{ .PageEnumPrefix }}"
{{- else -}}
#page_enum_prefix = "Page"
{{- end }}
{{ if .PageEnumSuffix -}}
page_enum_suffix = "{{ .PageEnumSuffix }}"
{{- else -}}
#page_enum_suffix = ""
{{- end }}

# Name of the variable used as funcMap.
# The variable must be defined in another file of the same package
# (ex: "templates/func-map.go").
# If not defined or blank, no funcMap will be used
{{ if .FuncMap -}}
func_map = ".FuncMap"
{{- else -}}
#func_map = ""
{{- end }}

# Base dir of the templates files
template_base_dir = "{{ .TemplateBaseDir }}"

# Templates used to render the Pages.
# Each template must have name and an array of string item.
# Each string item can be a:
#   - path of a file to load in the template creation. The file path is
#     relative to the template_base_dir folder.
#   - name of another template to include in the current template.
[templates]
{{- range $name, $files := .Templates }}
{{ $name }} = [{{ astr2str $files }}]
{{- end }}

# Pages to render.
# Each page must have name, a template name and optionally a base name.
# If defined, the base will be used in template.ExecuteTemplate as the name
# of the template. Otherwise will be called template.Execute.
[pages]
{{- range $name, $page := .Pages }}
{{ $name }} = {template="{{$page.Template}}"
{{- if $page.Base }}, base="{{ $page.Base }}"{{ end -}}
}
{{- end }}

{{ end }}



{{ define "func-init" }}
func init(){
	// init base templates
	for t := {{ .TemplateEnumType }}(0); t<templatesLen; t++ {
		files := t.Files()
{{- if .AssetManager.IsGoBindata -}}
{{/*-
	asset_manager == go-bindata
-*/}}
		// use go-bindata MustAsset func to load templates
		tmpl := template.New(filepath.Base(files[0])){{ if .FuncMap }}.Funcs({{ .FuncMap }}){{ end }}
		for _, path := range files {
			tmpl.Parse(string(MustAsset(path)))
		}
		mTemplates[t] = tmpl
{{- else -}}
{{/*-
	asset_manager == none
-*/}}
		mTemplates[t] = template.Must(
			{{- if .FuncMap -}}
			template.New(filepath.Base(files[0])).Funcs({{ .FuncMap }}).ParseFiles(files2paths(files)...)
			{{- else -}}
			template.ParseFiles(files2paths(files)...)
			{{- end -}}
		)
{{- end }}
	}
}
{{ end }}


